import { PDFDocument, PDFPage, rgb, degrees } from 'pdf-lib';
import { EnhancedHighlight } from './enhancedPdfHighlighter';

export interface HighlightAnnotation {
  page: number;
  text: string;
  type: string;
  color: { r: number; g: number; b: number; a: number };
  bounds: { x: number; y: number; width: number; height: number };
  importance: number;
  context: string;
}

export class PdfProcessor {
  /**
   * Add highlights to PDF and return downloadable blob
   */
  async addHighlightsToPdf(
    originalPdfUrl: string,
    highlights: EnhancedHighlight[],
    documentName: string
  ): Promise<Blob> {
    try {
      // Fetch the original PDF
      const response = await fetch(originalPdfUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch PDF: ${response.statusText}`);
      }
      
      const pdfArrayBuffer = await response.arrayBuffer();
      const pdfDoc = await PDFDocument.load(pdfArrayBuffer);
      
      // Group highlights by page
      const highlightsByPage = this.groupHighlightsByPage(highlights);
      
      // Add highlights to each page
      for (const [pageIndex, pageHighlights] of highlightsByPage.entries()) {
        await this.addHighlightsToPage(pdfDoc, pageIndex, pageHighlights);
      }
      
      // Add metadata
      pdfDoc.setTitle(`${documentName} (Highlighted)`);
      pdfDoc.setSubject('PDF with intelligent highlights generated by DocuSense');
      pdfDoc.setCreator('DocuSense - AI-Powered PDF Reader');
      pdfDoc.setProducer('DocuSense Highlight Engine');
      pdfDoc.setCreationDate(new Date());
      pdfDoc.setModificationDate(new Date());
      
      // Add custom metadata about highlights
      const highlightSummary = this.generateHighlightSummary(highlights);
      pdfDoc.setKeywords([
        'highlighted',
        'ai-analyzed',
        'docusense',
        `${highlights.length}-highlights`,
        ...highlightSummary.types
      ].join(', '));
      
      // Serialize the PDF
      const pdfBytes = await pdfDoc.save();
      
      // Return as blob
      return new Blob([pdfBytes], { type: 'application/pdf' });
      
    } catch (error) {
      console.error('Error processing PDF:', error);
      throw new Error(`Failed to add highlights to PDF: ${error.message}`);
    }
  }

  /**
   * Group highlights by page number
   */
  private groupHighlightsByPage(highlights: EnhancedHighlight[]): Map<number, EnhancedHighlight[]> {
    const grouped = new Map<number, EnhancedHighlight[]>();
    
    highlights.forEach(highlight => {
      const pageIndex = highlight.page - 1; // Convert to 0-based index
      if (!grouped.has(pageIndex)) {
        grouped.set(pageIndex, []);
      }
      grouped.get(pageIndex)!.push(highlight);
    });
    
    return grouped;
  }

  /**
   * Add highlights to a specific page
   */
  private async addHighlightsToPage(
    pdfDoc: PDFDocument,
    pageIndex: number,
    highlights: EnhancedHighlight[]
  ): Promise<void> {
    const pages = pdfDoc.getPages();
    if (pageIndex >= pages.length) {
      console.warn(`Page ${pageIndex + 1} not found in PDF`);
      return;
    }
    
    const page = pages[pageIndex];
    const { width: pageWidth, height: pageHeight } = page.getSize();
    
    // Sort highlights by importance (less important first, so more important ones appear on top)
    const sortedHighlights = highlights.sort((a, b) => a.importance - b.importance);
    
    for (const highlight of sortedHighlights) {
      await this.addHighlightToPage(page, highlight, pageWidth, pageHeight);
    }
    
    // Add a summary annotation at the bottom of the page if there are many highlights
    if (highlights.length > 3) {
      await this.addHighlightSummaryToPage(page, highlights, pageWidth, pageHeight);
    }
  }

  /**
   * Add a single highlight annotation to a page
   */
  private async addHighlightToPage(
    page: PDFPage,
    highlight: EnhancedHighlight,
    pageWidth: number,
    pageHeight: number
  ): Promise<void> {
    // Get color for highlight type
    const color = this.getHighlightColor(highlight.color);
    
    // Estimate text bounds (this is simplified - in a real implementation,
    // you'd need to analyze the PDF text layout more precisely)
    const bounds = this.estimateTextBounds(highlight.text, pageWidth, pageHeight);
    
    // Create highlight annotation
    page.drawRectangle({
      x: bounds.x,
      y: bounds.y,
      width: bounds.width,
      height: bounds.height,
      color: rgb(color.r, color.g, color.b),
      opacity: 0.3,
      borderColor: rgb(color.r * 0.8, color.g * 0.8, color.b * 0.8),
      borderWidth: 1,
    });
    
    // Add importance indicator for high-importance highlights
    if (highlight.importance > 0.8) {
      page.drawRectangle({
        x: bounds.x - 3,
        y: bounds.y - 3,
        width: bounds.width + 6,
        height: bounds.height + 6,
        color: rgb(color.r, color.g, color.b),
        opacity: 0.1,
        borderColor: rgb(color.r * 0.6, color.g * 0.6, color.b * 0.6),
        borderWidth: 2,
      });
    }
    
    // Add small type indicator
    const typeIndicator = this.getTypeIndicator(highlight.type);
    page.drawText(typeIndicator, {
      x: bounds.x + bounds.width - 15,
      y: bounds.y + bounds.height - 8,
      size: 8,
      color: rgb(0.2, 0.2, 0.2),
    });
  }

  /**
   * Add highlight summary to page
   */
  private async addHighlightSummaryToPage(
    page: PDFPage,
    highlights: EnhancedHighlight[],
    pageWidth: number,
    pageHeight: number
  ): Promise<void> {
    const summary = this.generateHighlightSummary(highlights);
    
    // Add summary box at bottom of page
    const summaryHeight = 40;
    const summaryY = 10;
    
    page.drawRectangle({
      x: 10,
      y: summaryY,
      width: pageWidth - 20,
      height: summaryHeight,
      color: rgb(0.95, 0.95, 0.95),
      opacity: 0.8,
      borderColor: rgb(0.7, 0.7, 0.7),
      borderWidth: 1,
    });
    
    // Add summary text
    page.drawText('DocuSense Highlights Summary', {
      x: 15,
      y: summaryY + 25,
      size: 10,
      color: rgb(0.2, 0.2, 0.2),
    });
    
    page.drawText(
      `${highlights.length} highlights: ${summary.types.join(', ')} | Avg. Importance: ${Math.round(summary.avgImportance * 100)}%`,
      {
        x: 15,
        y: summaryY + 12,
        size: 8,
        color: rgb(0.4, 0.4, 0.4),
      }
    );
  }

  /**
   * Generate highlight summary statistics
   */
  private generateHighlightSummary(highlights: EnhancedHighlight[]): {
    types: string[];
    avgImportance: number;
    totalHighlights: number;
  } {
    const typeCounts = new Map<string, number>();
    let totalImportance = 0;
    
    highlights.forEach(highlight => {
      typeCounts.set(highlight.type, (typeCounts.get(highlight.type) || 0) + 1);
      totalImportance += highlight.importance;
    });
    
    const types = Array.from(typeCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .map(([type, count]) => `${count} ${type}${count > 1 ? 's' : ''}`)
      .slice(0, 3); // Top 3 types
    
    return {
      types,
      avgImportance: highlights.length > 0 ? totalImportance / highlights.length : 0,
      totalHighlights: highlights.length
    };
  }

  /**
   * Get RGB color for highlight type
   */
  private getHighlightColor(colorType: string): { r: number; g: number; b: number } {
    const colors = {
      primary: { r: 0.996, g: 0.941, b: 0.541 },     // Yellow
      secondary: { r: 0.525, g: 0.937, b: 0.675 },   // Green
      tertiary: { r: 0.576, g: 0.773, b: 0.992 },    // Blue
      quaternary: { r: 0.992, g: 0.729, b: 0.455 },  // Orange
    };
    
    return colors[colorType as keyof typeof colors] || colors.primary;
  }

  /**
   * Get type indicator symbol
   */
  private getTypeIndicator(type: string): string {
    const indicators = {
      concept: 'üí°',
      definition: 'üìñ',
      data: 'üìä',
      action: '‚ö°',
      normal: '‚≠ê'
    };
    
    return indicators[type as keyof typeof indicators] || '‚≠ê';
  }

  /**
   * Estimate text bounds (simplified implementation)
   * In a real implementation, this would analyze the PDF text layout
   */
  private estimateTextBounds(
    text: string,
    pageWidth: number,
    pageHeight: number
  ): { x: number; y: number; width: number; height: number } {
    // This is a simplified estimation
    // In a real implementation, you'd need to:
    // 1. Extract text positions from the PDF
    // 2. Match the highlight text to actual text positions
    // 3. Calculate accurate bounds
    
    const textLength = text.length;
    const estimatedWidth = Math.min(textLength * 4, pageWidth * 0.8);
    const estimatedHeight = 16;
    
    // Place highlights in different vertical positions to avoid overlap
    const hash = this.simpleHash(text);
    const yPosition = (pageHeight * 0.7) - ((hash % 10) * 30);
    
    return {
      x: 50,
      y: yPosition,
      width: estimatedWidth,
      height: estimatedHeight
    };
  }

  /**
   * Simple hash function for text positioning
   */
  private simpleHash(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash);
  }

  /**
   * Extract text content from PDF for analysis
   */
  async extractTextFromPdf(pdfUrl: string): Promise<Map<number, string>> {
    try {
      const response = await fetch(pdfUrl);
      const pdfArrayBuffer = await response.arrayBuffer();
      const pdfDoc = await PDFDocument.load(pdfArrayBuffer);
      
      const pages = pdfDoc.getPages();
      const textByPage = new Map<number, string>();
      
      // Note: PDF-lib doesn't have built-in text extraction
      // In a real implementation, you'd use a library like pdf-parse or pdf2pic
      // For now, we'll return empty content and rely on the PDF viewer's text layer
      
      pages.forEach((page, index) => {
        textByPage.set(index + 1, ''); // Empty for now
      });
      
      return textByPage;
    } catch (error) {
      console.error('Error extracting text from PDF:', error);
      return new Map();
    }
  }

  /**
   * Create a new PDF with only highlights (no original content)
   */
  async createHighlightOnlyPdf(
    highlights: EnhancedHighlight[],
    documentName: string,
    pageCount: number
  ): Promise<Blob> {
    try {
      const pdfDoc = await PDFDocument.create();
      
      // Group highlights by page
      const highlightsByPage = this.groupHighlightsByPage(highlights);
      
      // Create pages and add highlights
      for (let i = 0; i < pageCount; i++) {
        const page = pdfDoc.addPage([612, 792]); // Standard letter size
        const pageHighlights = highlightsByPage.get(i) || [];
        
        if (pageHighlights.length > 0) {
          // Add page header
          page.drawText(`Page ${i + 1} - Highlights Summary`, {
            x: 50,
            y: 750,
            size: 16,
            color: rgb(0.2, 0.2, 0.2),
          });
          
          // Add highlights as text blocks
          let yPosition = 700;
          pageHighlights.forEach((highlight, index) => {
            const color = this.getHighlightColor(highlight.color);
            
            // Highlight type and importance
            page.drawText(
              `${this.getTypeIndicator(highlight.type)} ${highlight.type.toUpperCase()} (${Math.round(highlight.importance * 100)}%)`,
              {
                x: 50,
                y: yPosition,
                size: 12,
                color: rgb(color.r * 0.8, color.g * 0.8, color.b * 0.8),
              }
            );
            
            // Highlight text
            const maxWidth = 500;
            const lines = this.wrapText(highlight.text, maxWidth, 10);
            lines.forEach((line, lineIndex) => {
              page.drawText(line, {
                x: 50,
                y: yPosition - 20 - (lineIndex * 15),
                size: 10,
                color: rgb(0.2, 0.2, 0.2),
              });
            });
            
            // Context
            page.drawText(`Context: ${highlight.context}`, {
              x: 50,
              y: yPosition - 20 - (lines.length * 15) - 10,
              size: 8,
              color: rgb(0.5, 0.5, 0.5),
            });
            
            yPosition -= 60 + (lines.length * 15);
            
            // Add new page if running out of space
            if (yPosition < 100 && index < pageHighlights.length - 1) {
              const newPage = pdfDoc.addPage([612, 792]);
              yPosition = 750;
            }
          });
        }
      }
      
      // Add metadata
      pdfDoc.setTitle(`${documentName} - Highlights Only`);
      pdfDoc.setSubject('Extracted highlights from DocuSense analysis');
      pdfDoc.setCreator('DocuSense - AI-Powered PDF Reader');
      
      const pdfBytes = await pdfDoc.save();
      return new Blob([pdfBytes], { type: 'application/pdf' });
      
    } catch (error) {
      console.error('Error creating highlight-only PDF:', error);
      throw new Error(`Failed to create highlights PDF: ${error.message}`);
    }
  }

  /**
   * Wrap text to fit within specified width
   */
  private wrapText(text: string, maxWidth: number, fontSize: number): string[] {
    const words = text.split(' ');
    const lines: string[] = [];
    let currentLine = '';
    
    const avgCharWidth = fontSize * 0.6; // Approximate character width
    const maxCharsPerLine = Math.floor(maxWidth / avgCharWidth);
    
    words.forEach(word => {
      if ((currentLine + word).length <= maxCharsPerLine) {
        currentLine += (currentLine ? ' ' : '') + word;
      } else {
        if (currentLine) {
          lines.push(currentLine);
        }
        currentLine = word;
      }
    });
    
    if (currentLine) {
      lines.push(currentLine);
    }
    
    return lines;
  }
}

export const pdfProcessor = new PdfProcessor();